#set parameter
param 
(
  [Parameter(Mandatory=$true,HelpMessage="Specify age of snapshots to be deleted")]
  [alias("-d")]
  [ValidateNotNullOrEmpty()]
  [int]$days,
  [Parameter(Mandatory=$false,HelpMessage="Specify file where encrypted authentication is located")]
  [ValidateNotNullOrEmpty()]
  [alias("-s")]
  [string]$secret,
  [Parameter(Mandatory=$false,HelpMessage="Specify Blockbridge API end-point")]
  [ValidateNotNullOrEmpty()]
  [alias("-b","h","host")]
  [string]$bb
)

if ($PSVersionTable.PSVersion.Major -lt 7) {
  #This function sets up the Powershell environment to accept self-signed certificate
  function IgnoreCertificateValidity {
    if ("TrustAllCertsPolicy" -as [type]) {} else {
      Add-Type "using System.Net;using System.Security.Cryptography.X509Certificates;
      public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem) {return true;}
      }"
      [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    }
  }
  $IgnoreCert=@{"TimeoutSec" = "30" }
  ignoreCertificateValidity
} else {
  #in PS7 we can just use an argument and its cross-platform compatible
  $IgnoreCert=@{SkipCertificateCheck = true }
}

#Authorization token was generated via steps in README.md. It can be supplied as encrypted string from -s secretfile.txt
#Secretfile.txt can be generated by running following powershell command:
#    'AuthTokenString' |  ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString |  Set-Content -Path secretfile.txt
if ( $secret -ne $null -and $secret -ne "" ) {
  $EncAuthToken = Get-Content  -Path $secret | ConvertTo-SecureString
  $AuthToken=[Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR((($EncAuthToken))))
}
else {
  #Manually set token and save it in the script
  $AuthToken="1/UlfS9+....."
}

#BB_ControlPlane should be set to https://[IP|Name|FQDN]/api where IP|NAME|FQDN is the ControlPlane of Blockbridge system
if ( $bb -ne $null -and $bb -ne "" ) {
  $BB_ControlPlane="https://$bb/api"
}
else {
  $BB_ControlPlane="https://dogfood/api"
}

#Connectivity check
try {
  $my_result=Invoke-RestMethod @IgnoreCert -Method GET -Header $Header -ContentType "application/json" -uri $BB_ControlPlane"/status"
} catch {
  $_.Exception
  exit 1
}

#setup authentication header for REST request
$Header = @{"Authorization" = "Bearer $AuthToken" }

#setup label prefix. Snapshots created via this script will have below prefix in their label.
$prefix="Scheduled Snapshot"

#Dates in Blockbridge snapshot raw object are stored in UNIX Epoch time in milliseconds.
#Find number of milliseconds from epoch to today and subtract days specified by the -d/-days argument
$limit=(New-TimeSpan -Start (Get-Date "01/01/1970") -End (Get-Date).AddDays(-$days)).TotalMilliseconds

#get IDs of all snapshots and filter the list based on label match and age
$all_snapshots=(Invoke-RestMethod @IgnoreCert -Method GET -Header $Header -ContentType "application/json" -uri $BB_ControlPlane"/snapshot")
$snaps_to_remove=$all_snapshots| Where-Object {( $_.label -match $prefix -and $_.ctime -lt $limit )}

#Iterate through the list of matching snapshot objects and remove each one
$snaps_to_remove|foreach {
  $vdisk_id=$_.vdisk_id
  $label=$_.label
  $vss_id=$_.vss_id
  $vdisk_label=((Invoke-RestMethod @IgnoreCert -Method GET -Header $Header -ContentType "application/json" -uri $BB_ControlPlane"/vdisk/$vdisk_id").label )
  $vss_label=((Invoke-RestMethod @IgnoreCert -Method GET -Header $Header -ContentType "application/json" -uri $BB_ControlPlane"/vss/$vss_id").label )
  try {
    $RESTResponse = Invoke-RestMethod @IgnoreCert -Method DELETE -Header $Header -ContentType "application/json" -uri ( $BB_ControlPlane + "/snapshot/"  +$_.serial )
    Write-Host "Snapshot ""$label"" from disk ""$vdisk_label"" on VSS ""$vss_label"" was removed successfully"
    if ($RESTResponse -ne "") {
      return $RESTResponse
    } else {
      return
    }
  }
  catch {
    # Dig into the exception to get the Response details.
    # Note that value__ is not a typo.
    Write-Host "StatusCode:" $_.Exception.Response.StatusCode.value__
    Write-Host "StatusDescription:" $_.Exception.Response.StatusDescription
    Write-Host "ErrorDetails:" $_.ErrorDetails
    $my_error=1
  }
}

if ( $my_error -eq 1 ) { Write-Host "One or more snapshots failed to be deleted. Script did not complete successfully" ; exit 1}
